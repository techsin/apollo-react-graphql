{"ast":null,"code":"import { __assign } from 'tslib';\nimport invariant from 'ts-invariant';\nimport { getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { makeReference, getTypenameFromResult, valueToObjectRepresentation, isReference, storeKeyNameFromField, argumentsObjectFromField, isField } from '../../utilities/graphql/storeUtils.js';\nimport { canUseWeakMap } from '../../utilities/common/canUse.js';\nimport { KeyTrie, dep } from 'optimism';\nimport { maybeDeepFreeze } from '../../utilities/common/maybeDeepFreeze.js';\nimport { fieldNameFromStoreName, isFieldValueToBeMerged } from './helpers.js';\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction defaultDataIdFromObject(object) {\n  var __typename = object.__typename,\n      id = object.id,\n      _id = object._id;\n\n  if (typeof __typename === \"string\") {\n    if (typeof id !== \"undefined\") return __typename + \":\" + id;\n    if (typeof _id !== \"undefined\") return __typename + \":\" + _id;\n  }\n\n  return null;\n}\n\nvar nullKeyFieldsFn = function () {\n  return null;\n};\n\nvar simpleKeyArgsFn = function (field) {\n  return field.name.value;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    var _this = this;\n\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.rootTypenamesById = {\n      __proto__: null,\n      ROOT_QUERY: \"Query\",\n      ROOT_MUTATION: \"Mutation\",\n      ROOT_SUBSCRIPTION: \"Subscription\"\n    };\n    this.usingPossibleTypes = false;\n\n    this.toReference = function (object, selectionSet, fragmentMap) {\n      var id = _this.identify(object, selectionSet, fragmentMap);\n\n      return id && makeReference(id);\n    };\n\n    this.storageTrie = new KeyTrie(true);\n    this.fieldDep = dep();\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap,\n      policies: this\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn) {\n      id = keyFn(object, context);\n    } else {\n      id = this.config.dataIdFromObject ? this.config.dataIdFromObject(object, context) : null;\n    }\n\n    return id && String(id);\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n          fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : void 0;\n\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n          var incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n                read = incoming.read,\n                merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            if (typeof merge === \"function\") existing.merge = merge;\n          }\n\n          if (existing.read || existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(old === which, 38) : invariant(old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      var subtypeSet = _this.getSubtypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    var typePolicies = this.typePolicies;\n    return typePolicies[typename] || createIfMissing && (typePolicies[typename] = Object.create(null));\n  };\n\n  Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n    var policy = this.getTypePolicy(supertype, createIfMissing);\n\n    if (policy) {\n      return policy.subtypes || createIfMissing && (policy.subtypes = new Set());\n    }\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes) {\n      var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var subtypes = workQueue_1[i];\n\n        if (subtypes) {\n          if (subtypes.has(typename)) return true;\n          subtypes.forEach(function (subtype) {\n            var subsubtypes = _this.getSubtypeSet(subtype, false);\n\n            if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n              workQueue_1.push(subsubtypes);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.makeFieldValueGetter = function (store) {\n    var policies = this;\n    return function getFieldValue(objectOrReference, storeFieldName) {\n      var fieldValue;\n\n      if (isReference(objectOrReference)) {\n        var dataId = objectOrReference.__ref;\n        fieldValue = store.getFieldValue(dataId, storeFieldName);\n\n        if (fieldValue === void 0 && storeFieldName === \"__typename\") {\n          return policies.rootTypenamesById[dataId];\n        }\n      } else {\n        fieldValue = objectOrReference && objectOrReference[storeFieldName];\n      }\n\n      if (process.env.NODE_ENV !== \"production\") {\n        maybeDeepFreeze(fieldValue);\n      }\n\n      return fieldValue;\n    };\n  };\n\n  Policies.prototype.getStoreFieldName = function (typename, field, variables) {\n    var fieldName = field.name.value;\n    var storeFieldName;\n\n    if (typeof typename === \"string\") {\n      var policy = this.getFieldPolicy(typename, fieldName, false);\n      var keyFn = policy && policy.keyFn;\n\n      if (keyFn) {\n        storeFieldName = keyFn(field, {\n          typename: typename,\n          variables: variables,\n          policies: this\n        }) || fieldName;\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = storeKeyNameFromField(field, variables);\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (objectOrReference, nameOrField, getFieldValue, variables, typename) {\n    if (typename === void 0) {\n      typename = getFieldValue(objectOrReference, \"__typename\");\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(objectOrReference, 39) : invariant(objectOrReference, \"Must provide an object or Reference when calling Policies#readField\");\n    var policies = this;\n    var storeFieldName = typeof nameOrField === \"string\" ? nameOrField : policies.getStoreFieldName(typename, nameOrField, variables);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = getFieldValue(objectOrReference, storeFieldName);\n    var policy = policies.getFieldPolicy(typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var storage_1 = policies.storageTrie.lookup(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName);\n      policies.fieldDep(storage_1);\n      return read(existing, {\n        args: typeof nameOrField === \"string\" ? null : argumentsObjectFromField(nameOrField, variables),\n        field: typeof nameOrField === \"string\" ? null : nameOrField,\n        fieldName: fieldName,\n        variables: variables,\n        policies: policies,\n        isReference: isReference,\n        toReference: policies.toReference,\n        storage: storage_1,\n        readField: function (nameOrField, foreignObjOrRef) {\n          return policies.readField(foreignObjOrRef || objectOrReference, nameOrField, getFieldValue, variables);\n        },\n        invalidate: function () {\n          policies.fieldDep.dirty(storage_1);\n        }\n      });\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n\n  Policies.prototype.applyMerges = function (existing, incoming, getFieldValue, variables, storageKeys) {\n    var policies = this;\n\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var policy = policies.getFieldPolicy(incoming.__typename, fieldName, false);\n      var applied = policies.applyMerges(existing, incoming.__value, getFieldValue, variables, storageKeys);\n      var merge = policy && policy.merge;\n\n      if (merge) {\n        if (process.env.NODE_ENV !== \"production\") {\n          maybeDeepFreeze(existing);\n        }\n\n        var storage_2 = storageKeys ? policies.storageTrie.lookupArray(storageKeys) : null;\n        return merge(existing, applied, {\n          args: argumentsObjectFromField(field, variables),\n          field: field,\n          fieldName: fieldName,\n          variables: variables,\n          policies: policies,\n          isReference: isReference,\n          toReference: policies.toReference,\n          readField: function (nameOrField, foreignObjOrRef) {\n            return policies.readField(foreignObjOrRef, nameOrField, getFieldValue, variables);\n          },\n          storage: storage_2,\n          invalidate: function () {\n            if (storage_2) {\n              policies.fieldDep.dirty(storage_2);\n            }\n          }\n        });\n      }\n\n      return applied;\n    }\n\n    if (incoming && typeof incoming === \"object\") {\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        i_1[storeFieldName] = policies.applyMerges(getFieldValue(e_1, storeFieldName), i_1[storeFieldName], getFieldValue, variables, firstStorageKey_1 && [firstStorageKey_1, storeFieldName]);\n      });\n    }\n\n    return incoming;\n  };\n\n  return Policies;\n}();\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  var topLevelArgNames = Object.create(null);\n  specifier.forEach(function (name) {\n    if (typeof name === \"string\") {\n      topLevelArgNames[name] = true;\n    }\n  });\n  return function (field, context) {\n    var fieldName = field.name.value;\n\n    if (field.arguments && field.arguments.length > 0) {\n      var args_1 = Object.create(null);\n      field.arguments.forEach(function (arg) {\n        if (topLevelArgNames[arg.name.value] === true) {\n          valueToObjectRepresentation(args_1, arg.name, arg.value, context.variables);\n        }\n      });\n      return fieldName + \":\" + JSON.stringify(computeKeyObject(args_1, specifier));\n    }\n\n    return fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    return context.typename + \":\" + JSON.stringify(computeKeyObject(object, specifier, aliasMap));\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n        workQueue.add(fragment.selectionSet);\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 40) : invariant(hasOwn.call(response, responseName), \"Missing field \" + responseName + \" while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}\n\nexport { Policies, defaultDataIdFromObject };","map":{"version":3,"sources":["policies.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { dep, KeyTrie } from 'optimism';\nimport invariant from 'ts-invariant';\nimport { getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { isField, getTypenameFromResult, valueToObjectRepresentation, storeKeyNameFromField, argumentsObjectFromField, makeReference, isReference, } from '../../utilities/graphql/storeUtils';\nimport { maybeDeepFreeze } from '../../utilities/common/maybeDeepFreeze';\nimport { canUseWeakMap } from '../../utilities/common/canUse';\nimport { fieldNameFromStoreName, isFieldValueToBeMerged, } from './helpers';\nvar hasOwn = Object.prototype.hasOwnProperty;\nexport function defaultDataIdFromObject(object) {\n    var __typename = object.__typename, id = object.id, _id = object._id;\n    if (typeof __typename === \"string\") {\n        if (typeof id !== \"undefined\")\n            return __typename + \":\" + id;\n        if (typeof _id !== \"undefined\")\n            return __typename + \":\" + _id;\n    }\n    return null;\n}\nvar nullKeyFieldsFn = function () { return null; };\nvar simpleKeyArgsFn = function (field) { return field.name.value; };\nvar Policies = (function () {\n    function Policies(config) {\n        var _this = this;\n        if (config === void 0) { config = {}; }\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.rootTypenamesById = {\n            __proto__: null,\n            ROOT_QUERY: \"Query\",\n            ROOT_MUTATION: \"Mutation\",\n            ROOT_SUBSCRIPTION: \"Subscription\",\n        };\n        this.usingPossibleTypes = false;\n        this.toReference = function (object, selectionSet, fragmentMap) {\n            var id = _this.identify(object, selectionSet, fragmentMap);\n            return id && makeReference(id);\n        };\n        this.storageTrie = new KeyTrie(true);\n        this.fieldDep = dep();\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n        var typename = selectionSet && fragmentMap\n            ? getTypenameFromResult(object, selectionSet, fragmentMap)\n            : object.__typename;\n        var context = {\n            typename: typename,\n            selectionSet: selectionSet,\n            fragmentMap: fragmentMap,\n            policies: this,\n        };\n        var id;\n        var policy = this.getTypePolicy(typename, false);\n        var keyFn = policy && policy.keyFn;\n        if (keyFn) {\n            id = keyFn(object, context);\n        }\n        else {\n            id = this.config.dataIdFromObject\n                ? this.config.dataIdFromObject(object, context)\n                : null;\n        }\n        return id && String(id);\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var existing = _this.getTypePolicy(typename, true);\n            var incoming = typePolicies[typename];\n            var keyFields = incoming.keyFields, fields = incoming.fields;\n            if (incoming.queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (incoming.mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (incoming.subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            existing.keyFn =\n                keyFields === false ? nullKeyFieldsFn :\n                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                        typeof keyFields === \"function\" ? keyFields : void 0;\n            if (fields) {\n                Object.keys(fields).forEach(function (fieldName) {\n                    var existing = _this.getFieldPolicy(typename, fieldName, true);\n                    var incoming = fields[fieldName];\n                    if (typeof incoming === \"function\") {\n                        existing.read = incoming;\n                    }\n                    else {\n                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                        existing.keyFn =\n                            keyArgs === false ? simpleKeyArgsFn :\n                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                    typeof keyArgs === \"function\" ? keyArgs :\n                                        existing.keyFn;\n                        if (typeof read === \"function\")\n                            existing.read = read;\n                        if (typeof merge === \"function\")\n                            existing.merge = merge;\n                    }\n                    if (existing.read || existing.merge) {\n                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                    }\n                });\n            }\n        });\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(old === which, \"Cannot change root \" + which + \" __typename more than once\");\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            var subtypeSet = _this.getSubtypeSet(supertype, true);\n            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n        var typePolicies = this.typePolicies;\n        return typePolicies[typename] || (createIfMissing && (typePolicies[typename] = Object.create(null)));\n    };\n    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n        var policy = this.getTypePolicy(supertype, createIfMissing);\n        if (policy) {\n            return policy.subtypes || (createIfMissing && (policy.subtypes = new Set()));\n        }\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        var typePolicy = this.getTypePolicy(typename, createIfMissing);\n        if (typePolicy) {\n            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));\n            if (fieldPolicies) {\n                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n            }\n        }\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes) {\n            var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var subtypes = workQueue_1[i];\n                if (subtypes) {\n                    if (subtypes.has(typename))\n                        return true;\n                    subtypes.forEach(function (subtype) {\n                        var subsubtypes = _this.getSubtypeSet(subtype, false);\n                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n                            workQueue_1.push(subsubtypes);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.makeFieldValueGetter = function (store) {\n        var policies = this;\n        return function getFieldValue(objectOrReference, storeFieldName) {\n            var fieldValue;\n            if (isReference(objectOrReference)) {\n                var dataId = objectOrReference.__ref;\n                fieldValue = store.getFieldValue(dataId, storeFieldName);\n                if (fieldValue === void 0 && storeFieldName === \"__typename\") {\n                    return policies.rootTypenamesById[dataId];\n                }\n            }\n            else {\n                fieldValue = objectOrReference && objectOrReference[storeFieldName];\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                maybeDeepFreeze(fieldValue);\n            }\n            return fieldValue;\n        };\n    };\n    Policies.prototype.getStoreFieldName = function (typename, field, variables) {\n        var fieldName = field.name.value;\n        var storeFieldName;\n        if (typeof typename === \"string\") {\n            var policy = this.getFieldPolicy(typename, fieldName, false);\n            var keyFn = policy && policy.keyFn;\n            if (keyFn) {\n                storeFieldName = keyFn(field, {\n                    typename: typename,\n                    variables: variables,\n                    policies: this,\n                }) || fieldName;\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = storeKeyNameFromField(field, variables);\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (objectOrReference, nameOrField, getFieldValue, variables, typename) {\n        if (typename === void 0) { typename = getFieldValue(objectOrReference, \"__typename\"); }\n        invariant(objectOrReference, \"Must provide an object or Reference when calling Policies#readField\");\n        var policies = this;\n        var storeFieldName = typeof nameOrField === \"string\" ? nameOrField\n            : policies.getStoreFieldName(typename, nameOrField, variables);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = getFieldValue(objectOrReference, storeFieldName);\n        var policy = policies.getFieldPolicy(typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var storage_1 = policies.storageTrie.lookup(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName);\n            policies.fieldDep(storage_1);\n            return read(existing, {\n                args: typeof nameOrField === \"string\" ? null :\n                    argumentsObjectFromField(nameOrField, variables),\n                field: typeof nameOrField === \"string\" ? null : nameOrField,\n                fieldName: fieldName,\n                variables: variables,\n                policies: policies,\n                isReference: isReference,\n                toReference: policies.toReference,\n                storage: storage_1,\n                readField: function (nameOrField, foreignObjOrRef) {\n                    return policies.readField(foreignObjOrRef || objectOrReference, nameOrField, getFieldValue, variables);\n                },\n                invalidate: function () {\n                    policies.fieldDep.dirty(storage_1);\n                },\n            });\n        }\n        return existing;\n    };\n    Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.merge);\n    };\n    Policies.prototype.applyMerges = function (existing, incoming, getFieldValue, variables, storageKeys) {\n        var policies = this;\n        if (isFieldValueToBeMerged(incoming)) {\n            var field = incoming.__field;\n            var fieldName = field.name.value;\n            var policy = policies.getFieldPolicy(incoming.__typename, fieldName, false);\n            var applied = policies.applyMerges(existing, incoming.__value, getFieldValue, variables, storageKeys);\n            var merge = policy && policy.merge;\n            if (merge) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    maybeDeepFreeze(existing);\n                }\n                var storage_2 = storageKeys\n                    ? policies.storageTrie.lookupArray(storageKeys)\n                    : null;\n                return merge(existing, applied, {\n                    args: argumentsObjectFromField(field, variables),\n                    field: field,\n                    fieldName: fieldName,\n                    variables: variables,\n                    policies: policies,\n                    isReference: isReference,\n                    toReference: policies.toReference,\n                    readField: function (nameOrField, foreignObjOrRef) {\n                        return policies.readField(foreignObjOrRef, nameOrField, getFieldValue, variables);\n                    },\n                    storage: storage_2,\n                    invalidate: function () {\n                        if (storage_2) {\n                            policies.fieldDep.dirty(storage_2);\n                        }\n                    },\n                });\n            }\n            return applied;\n        }\n        if (incoming && typeof incoming === \"object\") {\n            var e_1 = existing;\n            var i_1 = incoming;\n            var firstStorageKey_1 = isReference(e_1)\n                ? e_1.__ref\n                : typeof e_1 === \"object\" && e_1;\n            Object.keys(i_1).forEach(function (storeFieldName) {\n                i_1[storeFieldName] = policies.applyMerges(getFieldValue(e_1, storeFieldName), i_1[storeFieldName], getFieldValue, variables, firstStorageKey_1 && [firstStorageKey_1, storeFieldName]);\n            });\n        }\n        return incoming;\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction keyArgsFnFromSpecifier(specifier) {\n    var topLevelArgNames = Object.create(null);\n    specifier.forEach(function (name) {\n        if (typeof name === \"string\") {\n            topLevelArgNames[name] = true;\n        }\n    });\n    return function (field, context) {\n        var fieldName = field.name.value;\n        if (field.arguments && field.arguments.length > 0) {\n            var args_1 = Object.create(null);\n            field.arguments.forEach(function (arg) {\n                if (topLevelArgNames[arg.name.value] === true) {\n                    valueToObjectRepresentation(args_1, arg.name, arg.value, context.variables);\n                }\n            });\n            return fieldName + \":\" + JSON.stringify(computeKeyObject(args_1, specifier));\n        }\n        return fieldName;\n    };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var trie = new KeyTrie(canUseWeakMap);\n    return function (object, context) {\n        var aliasMap;\n        if (context.selectionSet && context.fragmentMap) {\n            var info = trie.lookupArray([\n                context.selectionSet,\n                context.fragmentMap,\n            ]);\n            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n        }\n        return context.typename + \":\" + JSON.stringify(computeKeyObject(object, specifier, aliasMap));\n    };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n    var map = Object.create(null);\n    var workQueue = new Set([selectionSet]);\n    workQueue.forEach(function (selectionSet) {\n        selectionSet.selections.forEach(function (selection) {\n            if (isField(selection)) {\n                if (selection.alias) {\n                    var responseKey = selection.alias.value;\n                    var storeKey = selection.name.value;\n                    if (storeKey !== responseKey) {\n                        var aliases = map.aliases || (map.aliases = Object.create(null));\n                        aliases[storeKey] = responseKey;\n                    }\n                }\n                if (selection.selectionSet) {\n                    var subsets = map.subsets || (map.subsets = Object.create(null));\n                    subsets[selection.name.value] =\n                        makeAliasMap(selection.selectionSet, fragmentMap);\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, fragmentMap);\n                workQueue.add(fragment.selectionSet);\n            }\n        });\n    });\n    return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n    var keyObj = Object.create(null);\n    var prevKey;\n    specifier.forEach(function (s) {\n        if (Array.isArray(s)) {\n            if (typeof prevKey === \"string\") {\n                var subsets = aliasMap && aliasMap.subsets;\n                var subset = subsets && subsets[prevKey];\n                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n            }\n        }\n        else {\n            var aliases = aliasMap && aliasMap.aliases;\n            var responseName = aliases && aliases[s] || s;\n            invariant(hasOwn.call(response, responseName), \"Missing field \" + responseName + \" while computing key fields\");\n            keyObj[prevKey = s] = response[responseName];\n        }\n    });\n    return keyObj;\n}\n//# sourceMappingURL=policies.js.map"]},"metadata":{},"sourceType":"module"}