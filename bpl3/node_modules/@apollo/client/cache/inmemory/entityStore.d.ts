import { KeyTrie } from 'optimism';
import { StoreValue } from '../../utilities/graphql/storeUtils';
import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';
export declare abstract class EntityStore implements NormalizedCache {
    protected data: NormalizedCacheObject;
    readonly group: CacheGroup;
    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): EntityStore;
    abstract removeLayer(layerId: string): EntityStore;
    toObject(): NormalizedCacheObject;
    has(dataId: string): boolean;
    get(dataId: string): StoreObject;
    getFieldValue(dataId: string, storeFieldName: string): StoreValue;
    merge(dataId: string, incoming: StoreObject): void;
    delete(dataId: string, fieldName?: string): void;
    clear(): void;
    replace(newData: NormalizedCacheObject | null): void;
    private rootIds;
    retain(rootId: string): number;
    release(rootId: string): number;
    getRootIdSet(): Set<string>;
    gc(): string[];
    private refs;
    findChildRefIds(dataId: string): Record<string, true>;
    makeCacheKey(...args: any[]): object;
}
declare class CacheGroup {
    readonly caching: boolean;
    private d;
    constructor(caching: boolean);
    depend(dataId: string, storeFieldName?: string): void;
    dirty(dataId: string, storeFieldName?: string): void;
    readonly keyMaker: KeyTrie<object>;
}
export declare namespace EntityStore {
    class Root extends EntityStore {
        private sharedLayerGroup;
        constructor({ resultCaching, seed, }: {
            resultCaching?: boolean;
            seed?: NormalizedCacheObject;
        });
        addLayer(layerId: string, replay: (layer: EntityStore) => any): EntityStore;
        removeLayer(layerId: string): Root;
    }
}
export declare function supportsResultCaching(store: any): store is EntityStore;
export declare function defaultNormalizedCacheFactory(seed?: NormalizedCacheObject): NormalizedCache;
export {};
//# sourceMappingURL=entityStore.d.ts.map