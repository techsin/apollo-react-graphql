import { InlineFragmentNode, FragmentDefinitionNode, SelectionSetNode, FieldNode } from "graphql";
import { FragmentMap } from '../../utilities/graphql/fragments';
import { StoreValue, Reference, isReference } from '../../utilities/graphql/storeUtils';
import { IdGetter, StoreObject, NormalizedCache } from "./types";
import { FieldValueToBeMerged } from './helpers';
export declare type TypePolicies = {
    [__typename: string]: TypePolicy;
};
declare type KeySpecifier = (string | any[])[];
declare type KeyFieldsFunction = (object: Readonly<StoreObject>, context: {
    typename: string;
    selectionSet?: SelectionSetNode;
    fragmentMap?: FragmentMap;
    policies: Policies;
}) => ReturnType<IdGetter>;
declare type TypePolicy = {
    keyFields?: KeySpecifier | KeyFieldsFunction | false;
    queryType?: true;
    mutationType?: true;
    subscriptionType?: true;
    fields?: {
        [fieldName: string]: FieldPolicy<StoreValue> | FieldReadFunction<StoreValue>;
    };
};
declare type KeyArgsFunction = (field: FieldNode, context: {
    typename: string;
    variables: Record<string, any>;
    policies: Policies;
}) => ReturnType<IdGetter>;
export declare type FieldPolicy<TValue> = {
    keyArgs?: KeySpecifier | KeyArgsFunction | false;
    read?: FieldReadFunction<TValue>;
    merge?: FieldMergeFunction<TValue>;
};
export declare type FieldValueGetter = ReturnType<Policies["makeFieldValueGetter"]>;
declare type StorageType = Record<string, any>;
interface FieldFunctionOptions {
    args: Record<string, any> | null;
    fieldName: string;
    field: FieldNode | null;
    variables?: Record<string, any>;
    policies: Policies;
    isReference: typeof isReference;
    toReference: Policies["toReference"];
    readField<T = StoreValue>(nameOrField: string | FieldNode, foreignObjOrRef?: StoreObject | Reference): Readonly<T>;
    storage: StorageType;
    invalidate(): void;
}
declare type FieldReadFunction<TExisting, TResult = TExisting> = (existing: Readonly<TExisting> | undefined, options: FieldFunctionOptions) => TResult;
declare type FieldMergeFunction<TExisting> = (existing: Readonly<TExisting> | undefined, incoming: Readonly<StoreValue>, options: FieldFunctionOptions) => TExisting;
export declare function defaultDataIdFromObject(object: StoreObject): string;
export declare type PossibleTypesMap = {
    [supertype: string]: string[];
};
export declare class Policies {
    private config;
    private typePolicies;
    readonly rootTypenamesById: Readonly<Record<string, string>>;
    readonly usingPossibleTypes = false;
    constructor(config?: {
        dataIdFromObject?: KeyFieldsFunction;
        possibleTypes?: PossibleTypesMap;
        typePolicies?: TypePolicies;
    });
    toReference: (object: StoreObject, selectionSet?: SelectionSetNode, fragmentMap?: FragmentMap) => Reference;
    identify(object: StoreObject, selectionSet?: SelectionSetNode, fragmentMap?: FragmentMap): string | null;
    addTypePolicies(typePolicies: TypePolicies): void;
    private setRootTypename;
    addPossibleTypes(possibleTypes: PossibleTypesMap): void;
    private getTypePolicy;
    private getSubtypeSet;
    private getFieldPolicy;
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string): boolean;
    makeFieldValueGetter(store: NormalizedCache): <T = StoreValue>(objectOrReference: Reference | StoreObject, storeFieldName: string) => Readonly<T>;
    getStoreFieldName(typename: string | undefined, field: FieldNode, variables: Record<string, any>): string;
    private storageTrie;
    private fieldDep;
    readField<V = StoreValue>(objectOrReference: StoreObject | Reference, nameOrField: string | FieldNode, getFieldValue: FieldValueGetter, variables?: Record<string, any>, typename?: string): Readonly<V>;
    hasMergeFunction(typename: string, fieldName: string): boolean;
    applyMerges<T extends StoreValue>(existing: T | Reference, incoming: T | FieldValueToBeMerged, getFieldValue: FieldValueGetter, variables: Record<string, any>, storageKeys?: [string | StoreObject, string]): T;
}
export {};
//# sourceMappingURL=policies.d.ts.map