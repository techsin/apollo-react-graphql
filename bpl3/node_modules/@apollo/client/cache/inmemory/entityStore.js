import { __assign, __extends } from 'tslib';
import { invariant } from 'ts-invariant';
import { isReference } from '../../utilities/graphql/storeUtils.js';
import { canUseWeakMap } from '../../utilities/common/canUse.js';
import { equal } from '@wry/equality';
import { DeepMerger } from '../../utilities/common/mergeDeep.js';
import { KeyTrie, dep } from 'optimism';
import { fieldNameFromStoreName, getTypenameFromStoreObject } from './helpers.js';

var hasOwn = Object.prototype.hasOwnProperty;
var EntityStore = (function () {
    function EntityStore() {
        this.data = Object.create(null);
        this.rootIds = Object.create(null);
        this.refs = Object.create(null);
    }
    EntityStore.prototype.toObject = function () {
        return __assign({}, this.data);
    };
    EntityStore.prototype.has = function (dataId) {
        return this.get(dataId) !== void 0;
    };
    EntityStore.prototype.get = function (dataId) {
        this.group.depend(dataId);
        return this.data[dataId];
    };
    EntityStore.prototype.getFieldValue = function (dataId, storeFieldName) {
        this.group.depend(dataId, storeFieldName);
        var storeObject = this.data[dataId];
        return storeObject && storeObject[storeFieldName];
    };
    EntityStore.prototype.merge = function (dataId, incoming) {
        var _this = this;
        var existing = this.get(dataId);
        var merged = new DeepMerger(storeObjectReconciler)
            .merge(existing, incoming, this);
        if (merged !== existing) {
            this.data[dataId] = merged;
            delete this.refs[dataId];
            if (this.group.caching) {
                this.group.dirty(dataId);
                Object.keys(incoming).forEach(function (storeFieldName) {
                    if (!existing || incoming[storeFieldName] !== existing[storeFieldName]) {
                        _this.group.dirty(dataId, storeFieldName);
                    }
                });
            }
        }
    };
    EntityStore.prototype.delete = function (dataId, fieldName) {
        var _this = this;
        var storeObject = this.get(dataId);
        if (storeObject) {
            fieldName = fieldName && fieldNameFromStoreName(fieldName);
            var storeNamesToDelete_1 = [];
            Object.keys(storeObject).forEach(function (storeFieldName) {
                if (storeObject[storeFieldName] !== void 0 &&
                    (!fieldName || fieldName === fieldNameFromStoreName(storeFieldName))) {
                    storeNamesToDelete_1.push(storeFieldName);
                }
            });
            if (storeNamesToDelete_1.length) {
                var canDelete_1 = this instanceof EntityStore.Root;
                var remove_1 = function (obj, key) {
                    if (canDelete_1) {
                        delete obj[key];
                    }
                    else {
                        obj[key] = void 0;
                    }
                };
                delete this.refs[dataId];
                var fieldsToDirty_1 = Object.create(null);
                if (fieldName) {
                    var cleaned_1 = this.data[dataId] = __assign({}, storeObject);
                    storeNamesToDelete_1.forEach(function (storeFieldName) {
                        remove_1(cleaned_1, storeFieldName);
                    });
                    fieldsToDirty_1[fieldName] = true;
                }
                else {
                    remove_1(this.data, dataId);
                    storeNamesToDelete_1.forEach(function (storeFieldName) {
                        var fieldName = fieldNameFromStoreName(storeFieldName);
                        fieldsToDirty_1[fieldName] = true;
                    });
                }
                if (this.group.caching) {
                    this.group.dirty(dataId);
                    Object.keys(fieldsToDirty_1).forEach(function (fieldName) {
                        _this.group.dirty(dataId, fieldName);
                    });
                }
            }
        }
    };
    EntityStore.prototype.clear = function () {
        this.replace(null);
    };
    EntityStore.prototype.replace = function (newData) {
        var _this = this;
        Object.keys(this.data).forEach(function (dataId) {
            if (!(newData && hasOwn.call(newData, dataId))) {
                _this.delete(dataId);
            }
        });
        if (newData) {
            Object.keys(newData).forEach(function (dataId) {
                _this.merge(dataId, newData[dataId]);
            });
        }
    };
    EntityStore.prototype.retain = function (rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore.prototype.release = function (rootId) {
        if (this.rootIds[rootId] > 0) {
            var count = --this.rootIds[rootId];
            if (!count)
                delete this.rootIds[rootId];
            return count;
        }
        return 0;
    };
    EntityStore.prototype.getRootIdSet = function () {
        return new Set(Object.keys(this.rootIds));
    };
    EntityStore.prototype.gc = function () {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function (id) {
            if (hasOwn.call(snapshot, id)) {
                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                delete snapshot[id];
            }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
            var root_1 = this;
            while (root_1 instanceof Layer)
                root_1 = root_1.parent;
            idsToRemove.forEach(function (id) { return root_1.delete(id); });
        }
        return idsToRemove;
    };
    EntityStore.prototype.findChildRefIds = function (dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
            var found_1 = this.refs[dataId] = Object.create(null);
            var workSet_1 = new Set([this.data[dataId]]);
            var canTraverse_1 = function (obj) { return obj !== null && typeof obj === 'object'; };
            workSet_1.forEach(function (obj) {
                if (isReference(obj)) {
                    found_1[obj.__ref] = true;
                }
                else if (canTraverse_1(obj)) {
                    Object.values(obj)
                        .filter(canTraverse_1)
                        .forEach(workSet_1.add, workSet_1);
                }
            });
        }
        return this.refs[dataId];
    };
    EntityStore.prototype.makeCacheKey = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return this.group.keyMaker.lookupArray(args);
    };
    return EntityStore;
}());
var CacheGroup = (function () {
    function CacheGroup(caching) {
        this.caching = caching;
        this.d = null;
        this.keyMaker = new KeyTrie(canUseWeakMap);
        this.d = caching ? dep() : null;
    }
    CacheGroup.prototype.depend = function (dataId, storeFieldName) {
        if (this.d) {
            this.d(makeDepKey(dataId, storeFieldName));
        }
    };
    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {
        if (this.d) {
            this.d.dirty(typeof storeFieldName === "string"
                ? makeDepKey(dataId, storeFieldName)
                : makeDepKey(dataId));
        }
    };
    return CacheGroup;
}());
function makeDepKey(dataId, storeFieldName) {
    var parts = [dataId];
    if (typeof storeFieldName === "string") {
        parts.push(fieldNameFromStoreName(storeFieldName));
    }
    return JSON.stringify(parts);
}
(function (EntityStore) {
    var Root = (function (_super) {
        __extends(Root, _super);
        function Root(_a) {
            var _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
            var _this = _super.call(this) || this;
            _this.sharedLayerGroup = null;
            _this.group = new CacheGroup(resultCaching);
            _this.sharedLayerGroup = new CacheGroup(resultCaching);
            if (seed)
                _this.replace(seed);
            return _this;
        }
        Root.prototype.addLayer = function (layerId, replay) {
            return new Layer(layerId, this, replay, this.sharedLayerGroup);
        };
        Root.prototype.removeLayer = function (layerId) {
            return this;
        };
        return Root;
    }(EntityStore));
    EntityStore.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(id, parent, replay, group) {
        var _this = _super.call(this) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
    }
    Layer.prototype.addLayer = function (layerId, replay) {
        return new Layer(layerId, this, replay, this.group);
    };
    Layer.prototype.removeLayer = function (layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
            if (this.group.caching) {
                Object.keys(this.data).forEach(function (dataId) { return _this.delete(dataId); });
            }
            return parent;
        }
        if (parent === this.parent)
            return this;
        return parent.addLayer(this.id, this.replay);
    };
    Layer.prototype.toObject = function () {
        return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer.prototype.get = function (dataId) {
        if (hasOwn.call(this.data, dataId)) {
            return _super.prototype.get.call(this, dataId);
        }
        if (this.group.caching && this.group !== this.parent.group) {
            this.group.depend(dataId);
        }
        return this.parent.get(dataId);
    };
    Layer.prototype.getFieldValue = function (dataId, storeFieldName) {
        if (hasOwn.call(this.data, dataId)) {
            var storeObject = this.data[dataId];
            if (storeObject && hasOwn.call(storeObject, storeFieldName)) {
                return _super.prototype.getFieldValue.call(this, dataId, storeFieldName);
            }
        }
        if (this.group.caching && this.group !== this.parent.group) {
            this.group.depend(dataId, storeFieldName);
        }
        return this.parent.getFieldValue(dataId, storeFieldName);
    };
    Layer.prototype.getRootIdSet = function () {
        var ids = this.parent.getRootIdSet();
        _super.prototype.getRootIdSet.call(this).forEach(ids.add, ids);
        return ids;
    };
    Layer.prototype.findChildRefIds = function (dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    return Layer;
}(EntityStore));
var storeObjectReconciler = function (existingObject, incomingObject, property, store) {
    var existing = existingObject[property];
    var incoming = incomingObject[property];
    if (existing !== incoming &&
        this.isObject(existing) &&
        this.isObject(incoming)) {
        var eType = getTypenameFromStoreObject(store, existing);
        var iType = getTypenameFromStoreObject(store, incoming);
        if (typeof eType === 'string' &&
            typeof iType === 'string' &&
            eType !== iType) {
            return incoming;
        }
        process.env.NODE_ENV === "production" ? invariant(!isReference(existing) || isReference(incoming), 54) : invariant(!isReference(existing) || isReference(incoming), "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + existing.__ref + " for this object.");
        if (equal(existing, incoming)) {
            return existing;
        }
    }
    return incoming;
};
function supportsResultCaching(store) {
    return !!(store instanceof EntityStore && store.group.caching);
}
function defaultNormalizedCacheFactory(seed) {
    return new EntityStore.Root({ resultCaching: true, seed: seed });
}

export { EntityStore, defaultNormalizedCacheFactory, supportsResultCaching };
//# sourceMappingURL=entityStore.js.map
