import { __assign } from 'tslib';
import invariant from 'ts-invariant';
import { getFragmentFromSelection } from '../../utilities/graphql/fragments.js';
import { makeReference, getTypenameFromResult, valueToObjectRepresentation, isReference, storeKeyNameFromField, argumentsObjectFromField, isField } from '../../utilities/graphql/storeUtils.js';
import { canUseWeakMap } from '../../utilities/common/canUse.js';
import { KeyTrie, dep } from 'optimism';
import { maybeDeepFreeze } from '../../utilities/common/maybeDeepFreeze.js';
import { fieldNameFromStoreName, isFieldValueToBeMerged } from './helpers.js';

var hasOwn = Object.prototype.hasOwnProperty;
function defaultDataIdFromObject(object) {
    var __typename = object.__typename, id = object.id, _id = object._id;
    if (typeof __typename === "string") {
        if (typeof id !== "undefined")
            return __typename + ":" + id;
        if (typeof _id !== "undefined")
            return __typename + ":" + _id;
    }
    return null;
}
var nullKeyFieldsFn = function () { return null; };
var simpleKeyArgsFn = function (field) { return field.name.value; };
var Policies = (function () {
    function Policies(config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        this.config = config;
        this.typePolicies = Object.create(null);
        this.rootTypenamesById = {
            __proto__: null,
            ROOT_QUERY: "Query",
            ROOT_MUTATION: "Mutation",
            ROOT_SUBSCRIPTION: "Subscription",
        };
        this.usingPossibleTypes = false;
        this.toReference = function (object, selectionSet, fragmentMap) {
            var id = _this.identify(object, selectionSet, fragmentMap);
            return id && makeReference(id);
        };
        this.storageTrie = new KeyTrie(true);
        this.fieldDep = dep();
        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        if (config.possibleTypes) {
            this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
            this.addTypePolicies(config.typePolicies);
        }
    }
    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {
        var typename = selectionSet && fragmentMap
            ? getTypenameFromResult(object, selectionSet, fragmentMap)
            : object.__typename;
        var context = {
            typename: typename,
            selectionSet: selectionSet,
            fragmentMap: fragmentMap,
            policies: this,
        };
        var id;
        var policy = this.getTypePolicy(typename, false);
        var keyFn = policy && policy.keyFn;
        if (keyFn) {
            id = keyFn(object, context);
        }
        else {
            id = this.config.dataIdFromObject
                ? this.config.dataIdFromObject(object, context)
                : null;
        }
        return id && String(id);
    };
    Policies.prototype.addTypePolicies = function (typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function (typename) {
            var existing = _this.getTypePolicy(typename, true);
            var incoming = typePolicies[typename];
            var keyFields = incoming.keyFields, fields = incoming.fields;
            if (incoming.queryType)
                _this.setRootTypename("Query", typename);
            if (incoming.mutationType)
                _this.setRootTypename("Mutation", typename);
            if (incoming.subscriptionType)
                _this.setRootTypename("Subscription", typename);
            existing.keyFn =
                keyFields === false ? nullKeyFieldsFn :
                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :
                        typeof keyFields === "function" ? keyFields : void 0;
            if (fields) {
                Object.keys(fields).forEach(function (fieldName) {
                    var existing = _this.getFieldPolicy(typename, fieldName, true);
                    var incoming = fields[fieldName];
                    if (typeof incoming === "function") {
                        existing.read = incoming;
                    }
                    else {
                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;
                        existing.keyFn =
                            keyArgs === false ? simpleKeyArgsFn :
                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :
                                    typeof keyArgs === "function" ? keyArgs :
                                        existing.keyFn;
                        if (typeof read === "function")
                            existing.read = read;
                        if (typeof merge === "function")
                            existing.merge = merge;
                    }
                    if (existing.read || existing.merge) {
                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;
                    }
                });
            }
        });
    };
    Policies.prototype.setRootTypename = function (which, typename) {
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
            process.env.NODE_ENV === "production" ? invariant(old === which, 38) : invariant(old === which, "Cannot change root " + which + " __typename more than once");
            this.rootTypenamesById[rootId] = typename;
        }
    };
    Policies.prototype.addPossibleTypes = function (possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function (supertype) {
            var subtypeSet = _this.getSubtypeSet(supertype, true);
            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);
        });
    };
    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {
        var typePolicies = this.typePolicies;
        return typePolicies[typename] || (createIfMissing && (typePolicies[typename] = Object.create(null)));
    };
    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {
        var policy = this.getTypePolicy(supertype, createIfMissing);
        if (policy) {
            return policy.subtypes || (createIfMissing && (policy.subtypes = new Set()));
        }
    };
    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {
        var typePolicy = this.getTypePolicy(typename, createIfMissing);
        if (typePolicy) {
            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));
            if (fieldPolicies) {
                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));
            }
        }
    };
    Policies.prototype.fragmentMatches = function (fragment, typename) {
        var _this = this;
        if (!fragment.typeCondition)
            return true;
        if (!typename)
            return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
            return true;
        if (this.usingPossibleTypes) {
            var workQueue_1 = [this.getSubtypeSet(supertype, false)];
            for (var i = 0; i < workQueue_1.length; ++i) {
                var subtypes = workQueue_1[i];
                if (subtypes) {
                    if (subtypes.has(typename))
                        return true;
                    subtypes.forEach(function (subtype) {
                        var subsubtypes = _this.getSubtypeSet(subtype, false);
                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {
                            workQueue_1.push(subsubtypes);
                        }
                    });
                }
            }
        }
        return false;
    };
    Policies.prototype.makeFieldValueGetter = function (store) {
        var policies = this;
        return function getFieldValue(objectOrReference, storeFieldName) {
            var fieldValue;
            if (isReference(objectOrReference)) {
                var dataId = objectOrReference.__ref;
                fieldValue = store.getFieldValue(dataId, storeFieldName);
                if (fieldValue === void 0 && storeFieldName === "__typename") {
                    return policies.rootTypenamesById[dataId];
                }
            }
            else {
                fieldValue = objectOrReference && objectOrReference[storeFieldName];
            }
            if (process.env.NODE_ENV !== "production") {
                maybeDeepFreeze(fieldValue);
            }
            return fieldValue;
        };
    };
    Policies.prototype.getStoreFieldName = function (typename, field, variables) {
        var fieldName = field.name.value;
        var storeFieldName;
        if (typeof typename === "string") {
            var policy = this.getFieldPolicy(typename, fieldName, false);
            var keyFn = policy && policy.keyFn;
            if (keyFn) {
                storeFieldName = keyFn(field, {
                    typename: typename,
                    variables: variables,
                    policies: this,
                }) || fieldName;
            }
        }
        if (storeFieldName === void 0) {
            storeFieldName = storeKeyNameFromField(field, variables);
        }
        return fieldName === fieldNameFromStoreName(storeFieldName)
            ? storeFieldName
            : fieldName + ":" + storeFieldName;
    };
    Policies.prototype.readField = function (objectOrReference, nameOrField, getFieldValue, variables, typename) {
        if (typename === void 0) { typename = getFieldValue(objectOrReference, "__typename"); }
        process.env.NODE_ENV === "production" ? invariant(objectOrReference, 39) : invariant(objectOrReference, "Must provide an object or Reference when calling Policies#readField");
        var policies = this;
        var storeFieldName = typeof nameOrField === "string" ? nameOrField
            : policies.getStoreFieldName(typename, nameOrField, variables);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = getFieldValue(objectOrReference, storeFieldName);
        var policy = policies.getFieldPolicy(typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
            var storage_1 = policies.storageTrie.lookup(isReference(objectOrReference)
                ? objectOrReference.__ref
                : objectOrReference, storeFieldName);
            policies.fieldDep(storage_1);
            return read(existing, {
                args: typeof nameOrField === "string" ? null :
                    argumentsObjectFromField(nameOrField, variables),
                field: typeof nameOrField === "string" ? null : nameOrField,
                fieldName: fieldName,
                variables: variables,
                policies: policies,
                isReference: isReference,
                toReference: policies.toReference,
                storage: storage_1,
                readField: function (nameOrField, foreignObjOrRef) {
                    return policies.readField(foreignObjOrRef || objectOrReference, nameOrField, getFieldValue, variables);
                },
                invalidate: function () {
                    policies.fieldDep.dirty(storage_1);
                },
            });
        }
        return existing;
    };
    Policies.prototype.hasMergeFunction = function (typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.merge);
    };
    Policies.prototype.applyMerges = function (existing, incoming, getFieldValue, variables, storageKeys) {
        var policies = this;
        if (isFieldValueToBeMerged(incoming)) {
            var field = incoming.__field;
            var fieldName = field.name.value;
            var policy = policies.getFieldPolicy(incoming.__typename, fieldName, false);
            var applied = policies.applyMerges(existing, incoming.__value, getFieldValue, variables, storageKeys);
            var merge = policy && policy.merge;
            if (merge) {
                if (process.env.NODE_ENV !== "production") {
                    maybeDeepFreeze(existing);
                }
                var storage_2 = storageKeys
                    ? policies.storageTrie.lookupArray(storageKeys)
                    : null;
                return merge(existing, applied, {
                    args: argumentsObjectFromField(field, variables),
                    field: field,
                    fieldName: fieldName,
                    variables: variables,
                    policies: policies,
                    isReference: isReference,
                    toReference: policies.toReference,
                    readField: function (nameOrField, foreignObjOrRef) {
                        return policies.readField(foreignObjOrRef, nameOrField, getFieldValue, variables);
                    },
                    storage: storage_2,
                    invalidate: function () {
                        if (storage_2) {
                            policies.fieldDep.dirty(storage_2);
                        }
                    },
                });
            }
            return applied;
        }
        if (incoming && typeof incoming === "object") {
            var e_1 = existing;
            var i_1 = incoming;
            var firstStorageKey_1 = isReference(e_1)
                ? e_1.__ref
                : typeof e_1 === "object" && e_1;
            Object.keys(i_1).forEach(function (storeFieldName) {
                i_1[storeFieldName] = policies.applyMerges(getFieldValue(e_1, storeFieldName), i_1[storeFieldName], getFieldValue, variables, firstStorageKey_1 && [firstStorageKey_1, storeFieldName]);
            });
        }
        return incoming;
    };
    return Policies;
}());
function keyArgsFnFromSpecifier(specifier) {
    var topLevelArgNames = Object.create(null);
    specifier.forEach(function (name) {
        if (typeof name === "string") {
            topLevelArgNames[name] = true;
        }
    });
    return function (field, context) {
        var fieldName = field.name.value;
        if (field.arguments && field.arguments.length > 0) {
            var args_1 = Object.create(null);
            field.arguments.forEach(function (arg) {
                if (topLevelArgNames[arg.name.value] === true) {
                    valueToObjectRepresentation(args_1, arg.name, arg.value, context.variables);
                }
            });
            return fieldName + ":" + JSON.stringify(computeKeyObject(args_1, specifier));
        }
        return fieldName;
    };
}
function keyFieldsFnFromSpecifier(specifier) {
    var trie = new KeyTrie(canUseWeakMap);
    return function (object, context) {
        var aliasMap;
        if (context.selectionSet && context.fragmentMap) {
            var info = trie.lookupArray([
                context.selectionSet,
                context.fragmentMap,
            ]);
            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));
        }
        return context.typename + ":" + JSON.stringify(computeKeyObject(object, specifier, aliasMap));
    };
}
function makeAliasMap(selectionSet, fragmentMap) {
    var map = Object.create(null);
    var workQueue = new Set([selectionSet]);
    workQueue.forEach(function (selectionSet) {
        selectionSet.selections.forEach(function (selection) {
            if (isField(selection)) {
                if (selection.alias) {
                    var responseKey = selection.alias.value;
                    var storeKey = selection.name.value;
                    if (storeKey !== responseKey) {
                        var aliases = map.aliases || (map.aliases = Object.create(null));
                        aliases[storeKey] = responseKey;
                    }
                }
                if (selection.selectionSet) {
                    var subsets = map.subsets || (map.subsets = Object.create(null));
                    subsets[selection.name.value] =
                        makeAliasMap(selection.selectionSet, fragmentMap);
                }
            }
            else {
                var fragment = getFragmentFromSelection(selection, fragmentMap);
                workQueue.add(fragment.selectionSet);
            }
        });
    });
    return map;
}
function computeKeyObject(response, specifier, aliasMap) {
    var keyObj = Object.create(null);
    var prevKey;
    specifier.forEach(function (s) {
        if (Array.isArray(s)) {
            if (typeof prevKey === "string") {
                var subsets = aliasMap && aliasMap.subsets;
                var subset = subsets && subsets[prevKey];
                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);
            }
        }
        else {
            var aliases = aliasMap && aliasMap.aliases;
            var responseName = aliases && aliases[s] || s;
            process.env.NODE_ENV === "production" ? invariant(hasOwn.call(response, responseName), 40) : invariant(hasOwn.call(response, responseName), "Missing field " + responseName + " while computing key fields");
            keyObj[prevKey = s] = response[responseName];
        }
    });
    return keyObj;
}

export { Policies, defaultDataIdFromObject };
//# sourceMappingURL=policies.js.map
